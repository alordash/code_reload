use crate::runtime::models::BuildFnData;
use code_reload_core::constants;
use quote::ToTokens;

pub trait IOutputGenerator {
    fn generate(&self, build_fn_datas: Vec<BuildFnData>) -> String;
}

pub struct OutputGenerator;

impl IOutputGenerator for OutputGenerator {
    fn generate(&self, build_fn_datas: Vec<BuildFnData>) -> String {
        let formatted_build_fn_datas: Vec<_> = build_fn_datas
            .into_iter()
            .map(|build_fn_data| self.format_build_fn_data(build_fn_data))
            .collect();

        let payload_entries: Vec<_> = formatted_build_fn_datas
            .into_iter()
            .map(|formatted_build_fn_data| self.generate_payload_entry(formatted_build_fn_data))
            .collect();

        let mut payload_fields = String::new();
        let mut payload_fields_initialization = String::new();
        for payload_entry in payload_entries {
            payload_fields.push_str(&payload_entry.field);
            payload_fields.push(',');

            payload_fields_initialization.push_str(&payload_entry.field_initialization);
            payload_fields_initialization.push(',');
        }

        let output = format!(
            r#"// Autogenerated by code_reload crate.
#[rustfmt::skip]
pub mod __code_reload {{
    pub struct HotreloadPayload {{
        {payload_fields}
    }}

    impl code_reload::runtime::IHotreloadPayload for HotreloadPayload {{
        fn load(library_wrapper: &code_reload::runtime::LibraryWrapper) -> Self {{
            Self {{
                {payload_fields_initialization}
            }}
        }}
    }}

    pub static HOTRELOAD: code_reload::runtime::LockedHotreloadLibrary<HotreloadPayload> =
    std::sync::LazyLock::new(|| {{
        code_reload::runtime::HotreloadLibrary::load_locked(std::env!("CARGO_PKG_NAME"))
    }});
}}
"#
        );
        return output;
    }
}

impl OutputGenerator {
    fn format_build_fn_data(&self, build_fn_data: BuildFnData) -> FormattedBuildFnData {
        let bare_signature = build_fn_data.bare_signature().to_token_stream().to_string();
        let ident = build_fn_data.ident().to_token_stream().to_string();
        let formatted_build_fn_data = FormattedBuildFnData {
            bare_signature,
            ident,
        };
        return formatted_build_fn_data;
    }

    fn generate_payload_entry(
        &self,
        formatted_build_fn_data: FormattedBuildFnData,
    ) -> PayloadEntry {
        PayloadEntry {
            field: self.generate_field(&formatted_build_fn_data),
            field_initialization: self.generate_field_initialization(&formatted_build_fn_data),
        }
    }

    fn generate_field(&self, formatted_build_fn_data: &FormattedBuildFnData) -> String {
        format!(
            "pub {}: {}",
            formatted_build_fn_data.ident, formatted_build_fn_data.bare_signature
        )
    }

    fn generate_field_initialization(
        &self,
        formatted_build_fn_data: &FormattedBuildFnData,
    ) -> String {
        let symbol_name = format!(
            "{}_{}",
            constants::GENERATED_CODE_PREFIX,
            formatted_build_fn_data.ident
        );
        let field_initialization = format!(
            "{}: library_wrapper.get(b\"{}\").unwrap()",
            formatted_build_fn_data.ident, symbol_name
        );
        return field_initialization;
    }
}

struct FormattedBuildFnData {
    bare_signature: String,
    ident: String,
}

struct PayloadEntry {
    field: String,
    field_initialization: String,
}
