use crate::runtime::models::BuildFnData;
use code_reload_core::{SourceCodeId, constants};
use quote::ToTokens;

pub trait IOutputGenerator {
    fn generate(&self, build_fn_datas: Vec<BuildFnData>) -> String;
}

pub struct OutputGenerator;

impl IOutputGenerator for OutputGenerator {
    fn generate(&self, build_fn_datas: Vec<BuildFnData>) -> String {
        let formatted_build_fn_datas: Vec<_> = build_fn_datas
            .into_iter()
            .map(|build_fn_data| self.format_build_fn_data(build_fn_data))
            .collect();

        let payload_entries: Vec<_> = formatted_build_fn_datas
            .into_iter()
            .map(|formatted_build_fn_data| self.generate_payload_entry(formatted_build_fn_data))
            .collect();

        let mut module_usages = String::new();
        let mut payload_fields = String::new();
        let mut payload_fields_initialization = String::new();
        for payload_entry in payload_entries {
            // TODO - keep only unique module usages
            module_usages.push_str(&payload_entry.module_usage);

            payload_fields.push_str(&payload_entry.field);

            payload_fields_initialization.push_str(&payload_entry.field_initialization);
        }

        let output = format!(
            r#"// Autogenerated by code_reload crate.
#[rustfmt::skip]
pub mod __code_reload {{
    {module_usages}

    pub struct HotreloadPayload {{
        {payload_fields}
    }}

    impl code_reload::runtime::IHotreloadPayload for HotreloadPayload {{
        fn load(library_wrapper: &code_reload::LibraryWrapper) -> Self {{
            Self {{
                {payload_fields_initialization}
            }}
        }}
    }}

    pub static HOTRELOAD: code_reload::runtime::LockedHotreloadLibrary<HotreloadPayload> =
    std::sync::LazyLock::new(|| {{
        code_reload::runtime::HotreloadLibrary::load_locked(std::env!("CARGO_PKG_NAME"))
    }});
}}
"#
        );
        return output;
    }
}

impl OutputGenerator {
    fn format_build_fn_data(&self, build_fn_data: BuildFnData) -> FormattedBuildFnData {
        let source_code_id = build_fn_data.source_code_id().clone();
        let bare_signature = build_fn_data.bare_signature().to_token_stream().to_string();
        let ident = build_fn_data.ident().to_token_stream().to_string();
        let formatted_build_fn_data = FormattedBuildFnData {
            source_code_id,
            bare_signature,
            ident,
        };
        return formatted_build_fn_data;
    }

    fn generate_payload_entry(
        &self,
        formatted_build_fn_data: FormattedBuildFnData,
    ) -> PayloadEntry {
        let module_usage = self.generate_module_usage(&formatted_build_fn_data.source_code_id);
        let field = self.generate_field(&formatted_build_fn_data);
        let field_initialization = self.generate_field_initialization(&formatted_build_fn_data);
        PayloadEntry {
            module_usage,
            field,
            field_initialization,
        }
    }

    fn generate_field(&self, formatted_build_fn_data: &FormattedBuildFnData) -> String {
        format!(
            "pub {}: {},",
            formatted_build_fn_data.ident, formatted_build_fn_data.bare_signature
        )
    }

    fn generate_field_initialization(
        &self,
        formatted_build_fn_data: &FormattedBuildFnData,
    ) -> String {
        let symbol_name = &formatted_build_fn_data.ident;
        let field_initialization = format!(
            "{}: library_wrapper.get(b\"{}\").unwrap(),",
            formatted_build_fn_data.ident, symbol_name
        );
        return field_initialization;
    }

    fn generate_module_usage(&self, source_code_id: &SourceCodeId) -> String {
        let module_usage = format!("use {}::*;", source_code_id.get_module());

        return module_usage;
    }
}

struct FormattedBuildFnData {
    source_code_id: SourceCodeId,
    bare_signature: String,
    ident: String,
}

struct PayloadEntry {
    module_usage: String,
    field: String,
    field_initialization: String,
}
